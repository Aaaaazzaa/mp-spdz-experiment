#
# # sint: secret integers
# # you can assign public numbers to sint
#
#
# def test(actual, expected):
#
#     # you can reveal a number in order to print it
#
#     actual = actual.reveal()
#     print_ln('expected %s, got %s', expected, actual)
#
# # private inputs are read from Player-Data/Input-P<i>-0
# # or from standard input if using command-line option -I
#
#
# # comparisons produce 1 for true and 0 for false
#
# # if_else() can be used instead of branching
# # let's find out the larger number
#
# # arrays and loops work as follows
#
# #a = Array(100, sint)
#
# #@for_range(100)
# #def f(i):
# #    a[i] = sint(i) * sint(i - 1)
# #test(a[99], 99 * 98)
#
# # if you use loops, use Array to store results
# # don't do this
# # @for_range(100)
# # def f(i):
# #     a = sint(i)
# # test(a, 99)
#
# # sfix: fixed-point numbers
#
# # set the precision after the dot and in total
#
# #sfix.set_precision(16, 32)
#
# # and the output precision in decimal digits
#
# #print_float_precision(4)
#
# # you can do all basic arithmetic with sfix, including division
#
# #a = sfix(2)
# #b = sfix(-0.1)
#
# #test(a + b, 1.9)
# #test(a - b, 2.1)
# #test(a * b, -0.2)
# #test(a / b, -20)
# #test(a < b, 0)
# #test(a <= b, 0)
# #test(a >= b, 1)
# #test(a > b, 1)
# #test(a == b, 0)
# #test(a != b, 1)
# #
# #test((a < b).if_else(a, b), -0.1)
#
# # now let's do a computation with private inputs
# # party 0 supplies three number and party 1 supplies three percentages
# # we want to compute the weighted mean
#
# print_ln('Party 0: please input 8 numbers')
# print_ln('Party 1: please input any 8 numbers')
#
# #data = Matrix(2, 8, sfix)
#
# # use @for_range_opt for balanced optimization
# # but use Python loops if compile-time numbers are need (e.g., for players)
#
# a = Array(8, sint)
# b = Array(8, sint)
# # reads in 8 numbers
# print_ln('read in a')
# @for_range_opt(8)
# def _(i):
#     a[i] = sint.get_input_from(0)
#     print_ln('%s', a[i].reveal())
# print_ln('read in b')
# @for_range_opt(8)
# def _(i):
#     b[i] = sint.get_input_from(1)
#     print_ln('%s', b[i].reveal())
# # compute median = 50%-th rank
#
# total0 = sum(point for point in a)
# total1 = sum(point for point in b)
# print_ln('total0: %s, total1: %s', total0.reveal(), total1.reveal())
# #result = sum(point[0] * point[1] for point in data) / weight_total
#
# #Index = Matrix(2, 2, regint)
# #Index[0][0] = 0
# #Index[1][0] = 0
# #Index[0][1] = 7
# #Index[1][1] = 7
#
# #j = 0
# #for i in 1, 2, 3:
# #    j = j + 1
# #print_ln('loop = %s', j)
# a_index = 0
# b_index = 0
# for i in 4, 2, 1:
#     print_ln('finding k-rank of a at %s = %s', i, a[i + a_index].reveal())
#     print_ln('finding k-rank of b at %s = %s', i, b[i + b_index].reveal())
#     @if_e((a[i + a_index] > b[i + b_index]).reveal())
#     def _(a_index, b_index):
#         # print_ln('a[i + a_index] > b[i + b_index]: %s > %s', a[i + a_index].reveal(), b[i + b_index].reveal())
#         b_index = b_index + i + 1
#     @else_
#     def _(a_index, b_index):
#         a_index = a_index + i + 1
# # branching is supported also depending on revealed secret data
# # with garbled circuits this triggers a interruption of the garbling
#
# #@if_e((sum(point[0] for point in data) != 0).reveal())
# #def _():
# #    print_ln('weighted average: %s', result.reveal())
# #@else_
# #def _():
# #    print_ln('your inputs made no sense')
#
# # permutation matrix
#
# #M = Matrix(2, 2, sfix)
# #M[0][0] = 0
# #M[1][0] = 1
# #M[0][1] = 1
# #M[1][1] = 0
#
# # matrix multiplication
#
# #M = data * M
# #test(M[0][0], data[0][1].reveal())
# #test(M[1][1], data[1][0].reveal())

# sint: secret integers
# you can assign public numbers to sint
import math
size = 262144
logsize = int(math.log2(size))
print_ln('logsize: %s', logsize)
print_ln('Party 0: please input %s numbers', size)
print_ln('Party 1: please input any %s numbers', size)

a = Array(size, sfix)
b = Array(size, sfix)
# reads in 8 numbers
print_ln('read in a')
@for_range_opt(size)
def _(i):
    a[i] = sfix.get_input_from(0)
    # print_ln('%s', a[i].reveal())
print_ln('read in b')
@for_range_opt(size)
def _(i):
    b[i] = sfix.get_input_from(1)
    # print_ln('%s', b[i].reveal())
# compute median = 50%-th rank

total0 = sum(point for point in a)
total1 = sum(point for point in b)
print_ln('total0: %s, total1: %s', total0.reveal(), total1.reveal())
#result = sum(point[0] * point[1] for point in data) / weight_total

#Index = Matrix(2, 2, regint)
#Index[0][0] = 0
#Index[1][0] = 0
#Index[0][1] = 7
#Index[1][1] = 7

#j = 0
#for i in 1, 2, 3:
#    j = j + 1
#print_ln('loop = %s', j)
a_index = 0
b_index = 0
for k in range(logsize):
    i = (1 << (logsize - k - 1)) - 1
    # print_ln('finding k-rank of a at %s = %s', i, a[i + a_index].reveal())
    # print_ln('finding k-rank of b at %s = %s', i, b[i + b_index].reveal())
    conditionb = (a[i + a_index] > b[i + b_index]).reveal()
    conditiona = (a[i + a_index] < b[i + b_index]).reveal()  # not conditiona

    a_index = a_index + (conditiona * (i + 1))
    b_index = b_index + (conditionb * (i + 1))
    # print_ln('b_index = %s', b_index)
    # print_ln('a_index = %s', a_index)
print_ln('50%-rank = %s', (sum(a[a_index], b[b_index]) / sfix(2)).reveal())
# branching is supported also depending on revealed secret data
# with garbled circuits this triggers a interruption of the garbling

#@if_e((sum(point[0] for point in data) != 0).reveal())
#def _():
#    print_ln('weighted average: %s', result.reveal())
#@else_
#def _():
#    print_ln('your inputs made no sense')
# permutation matrix

#M = Matrix(2, 2, sfix)
#M[0][0] = 0
#M[1][0] = 1
#M[0][1] = 1
#M[1][1] = 0

# matrix multiplication

#M = data * M
#test(M[0][0], data[0][1].reveal())
#test(M[1][1], data[1][0].reveal())